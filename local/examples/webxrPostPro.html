<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Three.js - WebXR - Basic</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
        }

        #c {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
</body>
<script type="importmap">
    {
        "imports": {
            "three": "../module/three/build/three.module.js",
            "three/addons/": "../module/three/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { TexturePass } from 'three/addons/postprocessing/TexturePass.js';
    import { ClearPass } from 'three/addons/postprocessing/ClearPass.js';
    import { MaskPass, ClearMaskPass } from 'three/addons/postprocessing/MaskPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

    function main() {

        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });

        /// post pro 
        renderer.setClearColor(0xe0e0e0);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.autoClear = false;
        ///

        renderer.xr.enabled = true;
        document.body.appendChild(VRButton.createButton(renderer));


        const fov = 75;
        const aspect = 2; // the canvas default
        const near = 0.1;
        const far = 50;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(0, 1.6, 0);

        const scene1 = new THREE.Scene();
        const scene2 = new THREE.Scene();

        let box = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1));
        box.position.x = 0;
        box.position.y = 0;
        box.position.z = - 4;
        scene1.add(box);

        let torus = new THREE.Mesh(new THREE.TorusGeometry(1, 0.5, 16, 32));
        torus.position.x = 0;
        torus.position.y = 1.6;
        torus.position.z = - 4;
        scene2.add(torus);

        const scene = new THREE.Scene();
        const color = 0xFFFFFF;
        const intensity = 3;
        const light = new THREE.DirectionalLight(color, intensity);
        light.position.set(- 1, 2, 4);
        scene.add(light);

        const boxWidth = 1;
        const boxHeight = 1;
        const boxDepth = 1;
        const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);


        const clearPass = new ClearPass();
        const clearMaskPass = new ClearMaskPass();
        const maskPass1 = new MaskPass(scene1, camera);
        const maskPass2 = new MaskPass(scene2, camera);
        const texture1 = new THREE.TextureLoader().load('textures/758px-Canestra_di_frutta_(Caravaggio).jpg');
        texture1.colorSpace = THREE.SRGBColorSpace;
        texture1.minFilter = THREE.LinearFilter;
        const texture2 = new THREE.TextureLoader().load('textures/2294472375_24a3b8ef46_o.jpg');
        texture2.colorSpace = THREE.SRGBColorSpace;
        const texturePass1 = new TexturePass(texture1);
        const texturePass2 = new TexturePass(texture2);
        const outputPass = new OutputPass();
        const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { stencilBuffer: true });

        let composer = new EffectComposer(renderer, renderTarget);
        composer.addPass(clearPass);
        composer.addPass(maskPass1);
        composer.addPass(texturePass1);
        composer.addPass(clearMaskPass);
        composer.addPass(maskPass2);
        composer.addPass(texturePass2);
        composer.addPass(clearMaskPass);
        composer.addPass(outputPass);

        function makeInstance(geometry, color, x) {

            const material = new THREE.MeshPhongMaterial({ color });

            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            cube.position.x = x;
            cube.position.y = 1.6;
            cube.position.z = - 2;

            return cube;

        }

        const cubes = [
            makeInstance(geometry, 0x44aa88, 0),
            makeInstance(geometry, 0x8844aa, - 2),
            makeInstance(geometry, 0xaa8844, 2),
        ];

        function resizeRendererToDisplaySize(renderer) {

            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {

                renderer.setSize(width, height, false);

            }

            return needResize;

        }

        function render(time) {

            time *= 0.001;

            if (resizeRendererToDisplaySize(renderer)) {

                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();

            }

            cubes.forEach((cube, ndx) => {

                const speed = 1 + ndx * .1;
                const rot = time * speed;
                cube.rotation.x = rot;
                cube.rotation.y = rot;

            });

            renderer.clear();
            composer.render(time);
            // renderer.render(scene, camera);

        }

        renderer.setAnimationLoop(render);

    }

    main();
</script>

</html>